
+------------------+  <- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  <- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  <- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  <- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  <- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  <- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  <- 0x00000000

Low Memory:早期PC可以使用的RAM 640KB
0x000A0000 --- 0x000FFFFF:被特殊用途的硬件所保留（video display buffers和保存在非易失性存储器中的固件）

BIOS:0X000F0000 --- 0X000FFFFF:64KB大小的Basic Input/Output System,以前放在真的ROM中，现在放在可更新的闪存中。

BIOS所做的工作：建立中断描述符表，系统的初始化工作  --->从存储中加载操作系统  --->将机器的控制权交给操作系统

初始化工作如：激活显卡，检查已安装的内存数目
尽管有了32位的处理器，为了向后兼容，0x00000000 --- 0x00010000仍然保留，其中前640KB是低地址，剩下的384KB是
拓展的地址。这384KB像一个洞一样。

开机的第一条指令是在0xFFFF0  0XF000:0X0FFF处执行的，距离保留的0xFFFFF只有16KB
执行一条跳转指令到前面某个地址，执行BIOS,建立中断描述符表，初始化一些设备，(比如说给一些输入输出设备分配串口地址，激活显卡之类的工作)，
然后搜索可引导的设备(实质上是在从存储设备甚至是网络上面寻找boot loader)，
最终当他找到一个boot loader后，读取boot loader，把控制权交给boot loader引导的操作系统。

在BIOS程序找到512KB的引导扇区之后，它把引导扇区加载到内存中，物理地址为0x7c00到0x7dff中，然后执行jmp指令，设置cs:ip为0000：7c00，把控制权交给
boot loader.

Boot Loader 主要做两件事情：
1、将CPU从实模式转换到保护模式
2、从硬盘里读取kernel(通过x86的IO指令，直接访问IDE磁盘寄存器，IDE就是存储设备与电脑的接口)

tips:第一块磁盘的引导扇区存储着boot loader，第二块磁盘扇区里面存储着kernel image
image理解成保存着激活其他实时工作的信息的文件

